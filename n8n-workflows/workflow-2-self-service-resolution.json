{
  "name": "Support - 2. Self-Service Resolution Engine",
  "nodes": [
    {
      "parameters": {
        "path": "support/self-service",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Self-Service",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [240, 300],
      "webhookId": "support-self-service-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Extract case data from incoming request\nconst input = $input.item.json;\n\n// Handle both direct body and nested body scenarios\nconst caseData = input.body || input;\n\nreturn {\n  json: {\n    case_id: caseData.case_id,\n    request_id: caseData.request_id,\n    description: caseData.description,\n    classification: caseData.classification,\n    customer_context: caseData.customer_context,\n    product: caseData.product,\n    product_version: caseData.product_version,\n    environment: caseData.environment,\n    channel: caseData.channel,\n    received_at: caseData.received_at,\n    triaged_at: caseData.triaged_at,\n    self_service_started_at: new Date().toISOString()\n  }\n};"
      },
      "id": "extract-case-data",
      "name": "Extract Case Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  error_code,\n  product,\n  description as error_description,\n  severity,\n  diagnostic_steps,\n  resolution_steps,\n  automated_fix_available,\n  automation_script,\n  kb_article_id\nFROM error_codes\nWHERE '{{ $json.description }}' ILIKE '%' || error_code || '%'\n   OR '{{ $json.description }}' ILIKE '%' || description || '%'\nLIMIT 5;",
        "options": {}
      },
      "id": "lookup-error-codes",
      "name": "Lookup Error Codes",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [680, 200],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  c.case_id,\n  c.description,\n  c.category,\n  c.subcategory,\n  c.resolution_type,\n  ci.message as solution,\n  c.satisfaction_score\nFROM cases c\nJOIN case_interactions ci ON c.case_id = ci.case_id\nWHERE c.status = 'resolved'\n  AND c.category = '{{ $json.classification.category }}'\n  AND ci.interaction_type = 'solution'\n  AND c.satisfaction_score >= 4\nORDER BY c.resolved_at DESC\nLIMIT 5;",
        "options": {}
      },
      "id": "find-similar-cases",
      "name": "Find Similar Resolved Cases",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [680, 400],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "mode": "raw",
        "query": "={{ $json.description }} {{ $json.classification.category }} {{ $json.classification.subcategory }} {{ $json.product }}",
        "topK": 5,
        "options": {}
      },
      "id": "vector-store-retrieval",
      "name": "KB Vector Search",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.1,
      "position": [680, 600],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-large",
        "options": {}
      },
      "id": "embeddings-openai",
      "name": "Embeddings OpenAI",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [680, 800],
      "credentials": {
        "openAiApi": {
          "id": "YOUR_OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge all knowledge sources\nconst caseData = $('Extract Case Data').first().json;\nconst errorCodes = $('Lookup Error Codes').all().map(item => item.json);\nconst similarCases = $('Find Similar Resolved Cases').all().map(item => item.json);\nconst kbArticles = $('KB Vector Search').all().map(item => item.json);\n\nreturn {\n  json: {\n    ...caseData,\n    knowledge_context: {\n      error_codes: errorCodes.filter(e => e.error_code),\n      similar_cases: similarCases.filter(c => c.case_id),\n      kb_articles: kbArticles.filter(a => a.content || a.pageContent),\n      has_automated_fix: errorCodes.some(e => e.automated_fix_available)\n    }\n  }\n};"
      },
      "id": "merge-knowledge",
      "name": "Merge Knowledge Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 300]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are an expert technical support engineer. Your role is to provide clear, actionable solutions to customer issues.\n\n## Customer Issue:\n{{ $json.description }}\n\n## Issue Classification:\n- Category: {{ $json.classification.category }}\n- Subcategory: {{ $json.classification.subcategory }}\n- Priority: {{ $json.classification.priority }}\n- Complexity: {{ $json.classification.estimated_complexity }}\n\n## Customer Context:\n- Account Tier: {{ $json.customer_context.account_tier }}\n- Total Past Cases: {{ $json.customer_context.total_cases }}\n- Product: {{ $json.product }}\n- Environment: {{ $json.environment }}\n\n## Knowledge Base Context:\n\n### Relevant Error Codes:\n{{ JSON.stringify($json.knowledge_context.error_codes, null, 2) }}\n\n### Similar Resolved Cases:\n{{ JSON.stringify($json.knowledge_context.similar_cases, null, 2) }}\n\n### Relevant KB Articles:\n{{ JSON.stringify($json.knowledge_context.kb_articles.map(a => a.pageContent || a.content).slice(0, 3), null, 2) }}\n\n### Automated Fix Available: {{ $json.knowledge_context.has_automated_fix }}\n\n## Your Task:\nProvide a comprehensive solution that includes:\n1. Step-by-step resolution instructions (clear, numbered)\n2. Diagnostic commands to verify the issue\n3. Expected outcomes after each step\n4. Links to relevant documentation\n5. Estimated time to resolution\n\n## Guidelines:\n- Always start with the simplest solution first\n- Include verification steps after each major action\n- Be explicit about any risks or reversible actions\n- Use customer-friendly language, avoid jargon\n- If automated fix is available, recommend it but note approval requirement\n- If unsure, set confidence lower and recommend human review\n\n## Important:\n- Set requires_approval = true if solution involves data changes, restarts, or automated fixes\n- Set automated_fix_available = true only if knowledge context confirms it\n- Reference specific KB articles or error codes in your solution",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "solution-generator-agent",
      "name": "Solution Generator Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [1160, 300]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-20250514",
        "options": {
          "maxTokensToSample": 4096,
          "temperature": 0.4
        }
      },
      "id": "claude-model-solution",
      "name": "Claude Sonnet - Solution",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [1160, 520]
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"solution_steps\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" },\n      \"description\": \"Step-by-step resolution instructions\"\n    },\n    \"diagnostic_commands\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" },\n      \"description\": \"Commands to diagnose and verify the issue\"\n    },\n    \"automated_fix_available\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether an automated fix can be applied\"\n    },\n    \"automation_script_name\": {\n      \"type\": \"string\",\n      \"description\": \"Name of the automation script if available\"\n    },\n    \"estimated_time\": {\n      \"type\": \"number\",\n      \"description\": \"Estimated resolution time in minutes\"\n    },\n    \"confidence\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"description\": \"Confidence in the solution (0-1)\"\n    },\n    \"references\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": { \"type\": \"string\" },\n          \"id\": { \"type\": \"string\" },\n          \"title\": { \"type\": \"string\" }\n        }\n      },\n      \"description\": \"Source references for the solution\"\n    },\n    \"risks\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" },\n      \"description\": \"Any risks involved in applying the solution\"\n    },\n    \"requires_approval\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether customer approval is needed before proceeding\"\n    },\n    \"reasoning\": {\n      \"type\": \"string\",\n      \"description\": \"Why this solution addresses the issue\"\n    },\n    \"fallback_solution\": {\n      \"type\": \"string\",\n      \"description\": \"Alternative approach if primary solution fails\"\n    }\n  },\n  \"required\": [\"solution_steps\", \"estimated_time\", \"confidence\", \"reasoning\", \"requires_approval\"]\n}"
      },
      "id": "solution-output-parser",
      "name": "Solution Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [1360, 520]
    },
    {
      "parameters": {
        "jsCode": "// Combine case data with generated solution\nconst caseData = $('Merge Knowledge Sources').first().json;\nconst solution = $input.item.json.output || $input.item.json;\n\nreturn {\n  json: {\n    ...caseData,\n    solution: {\n      steps: solution.solution_steps || [],\n      diagnostic_commands: solution.diagnostic_commands || [],\n      automated_fix_available: solution.automated_fix_available || false,\n      automation_script_name: solution.automation_script_name,\n      estimated_time: solution.estimated_time || 15,\n      confidence: solution.confidence || 0.7,\n      references: solution.references || [],\n      risks: solution.risks || [],\n      requires_approval: solution.requires_approval || false,\n      reasoning: solution.reasoning,\n      fallback_solution: solution.fallback_solution\n    },\n    solution_generated_at: new Date().toISOString()\n  }\n};"
      },
      "id": "combine-solution",
      "name": "Combine Solution",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1380, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            {
              "id": "check-approval",
              "leftValue": "={{ $json.solution.requires_approval }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-approval-needed",
      "name": "Requires Approval?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE cases \nSET status = 'awaiting_approval',\n    metadata = metadata || '{{ JSON.stringify({ solution_pending: true, solution_generated_at: $json.solution_generated_at }) }}'::jsonb\nWHERE case_id = '{{ $json.case_id }}';",
        "options": {}
      },
      "id": "update-awaiting-approval",
      "name": "Update Awaiting Approval",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1820, 200],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format solution for customer-friendly presentation\nconst data = $input.item.json;\nconst solution = data.solution;\n\nlet formattedSolution = `## Solution for Your Issue\\n\\n`;\nformattedSolution += `**Estimated Time:** ${solution.estimated_time} minutes\\n\\n`;\n\nformattedSolution += `### Steps to Resolve:\\n`;\nsolution.steps.forEach((step, i) => {\n  formattedSolution += `${i + 1}. ${step}\\n`;\n});\n\nif (solution.diagnostic_commands && solution.diagnostic_commands.length > 0) {\n  formattedSolution += `\\n### Diagnostic Commands:\\n`;\n  formattedSolution += \"```\\n\";\n  solution.diagnostic_commands.forEach(cmd => {\n    formattedSolution += `${cmd}\\n`;\n  });\n  formattedSolution += \"```\\n\";\n}\n\nif (solution.risks && solution.risks.length > 0) {\n  formattedSolution += `\\n### Important Notes:\\n`;\n  solution.risks.forEach(risk => {\n    formattedSolution += `- ‚ö†Ô∏è ${risk}\\n`;\n  });\n}\n\nif (solution.automated_fix_available) {\n  formattedSolution += `\\n### Automated Fix Available\\n`;\n  formattedSolution += `We can automatically apply a fix for this issue. Would you like us to proceed?\\n`;\n  formattedSolution += `\\n**To approve:** Reply with \"APPROVE\" or click the approval link below.\\n`;\n}\n\nif (solution.references && solution.references.length > 0) {\n  formattedSolution += `\\n### Related Documentation:\\n`;\n  solution.references.forEach(ref => {\n    formattedSolution += `- ${ref.title || ref.type}: ${ref.id}\\n`;\n  });\n}\n\nreturn {\n  json: {\n    ...data,\n    formatted_solution: formattedSolution,\n    approval_url: `${$env.N8N_WEBHOOK_BASE_URL}/webhook/support/approve/${data.case_id}`,\n    decline_url: `${$env.N8N_WEBHOOK_BASE_URL}/webhook/support/decline/${data.case_id}`\n  }\n};"
      },
      "id": "format-for-approval",
      "name": "Format For Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2040, 200]
    },
    {
      "parameters": {
        "sendTo": "={{ $json.customer_context.email }}",
        "subject": "Support Case #{{ $json.case_id }}: Solution Ready for Your Review",
        "message": "Dear {{ $json.customer_context.name }},\n\nWe've analyzed your support request and have a solution ready.\n\n---\n\n{{ $json.formatted_solution }}\n\n---\n\n**Approval Required**\n\nBefore we can proceed with any automated fixes or major changes, we need your approval.\n\n‚úÖ [Approve Solution]({{ $json.approval_url }})\n‚ùå [Decline / Request Changes]({{ $json.decline_url }})\n\n---\n\n**Case Details:**\n- Case ID: {{ $json.case_id }}\n- Category: {{ $json.classification.category }}\n- Priority: {{ $json.classification.priority }}\n\nIf you have questions, simply reply to this email.\n\nBest regards,\nSupport Team",
        "options": {}
      },
      "id": "send-approval-email",
      "name": "Send Approval Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2260, 200],
      "credentials": {
        "gmailOAuth2": {
          "id": "YOUR_GMAIL_CREDENTIAL_ID",
          "name": "Gmail"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  success: true,\n  case_id: $json.case_id,\n  status: 'awaiting_approval',\n  message: 'Solution generated. Customer notified for approval.',\n  solution_summary: {\n    estimated_time: $json.solution.estimated_time,\n    confidence: $json.solution.confidence,\n    automated_fix_available: $json.solution.automated_fix_available\n  }\n}, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" }
            ]
          }
        }
      },
      "id": "respond-approval-needed",
      "name": "Respond - Approval Needed",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [2480, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE cases \nSET status = 'in_progress',\n    metadata = metadata || '{{ JSON.stringify({ solution_started_at: new Date().toISOString() }) }}'::jsonb\nWHERE case_id = '{{ $json.case_id }}';",
        "options": {}
      },
      "id": "update-in-progress",
      "name": "Update In Progress",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1820, 400],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format solution for direct delivery (no approval needed)\nconst data = $input.item.json;\nconst solution = data.solution;\n\nlet formattedSolution = `## Solution for Your Issue\\n\\n`;\nformattedSolution += `**Estimated Time:** ${solution.estimated_time} minutes\\n\\n`;\n\nformattedSolution += `### Steps to Resolve:\\n`;\nsolution.steps.forEach((step, i) => {\n  formattedSolution += `${i + 1}. ${step}\\n`;\n});\n\nif (solution.diagnostic_commands && solution.diagnostic_commands.length > 0) {\n  formattedSolution += `\\n### Diagnostic Commands:\\n`;\n  formattedSolution += \"```\\n\";\n  solution.diagnostic_commands.forEach(cmd => {\n    formattedSolution += `${cmd}\\n`;\n  });\n  formattedSolution += \"```\\n\";\n}\n\nif (solution.references && solution.references.length > 0) {\n  formattedSolution += `\\n### Related Documentation:\\n`;\n  solution.references.forEach(ref => {\n    formattedSolution += `- ${ref.title || ref.type}: ${ref.id}\\n`;\n  });\n}\n\nformattedSolution += `\\n---\\n`;\nformattedSolution += `\\nIf this solution resolves your issue, please let us know!\\n`;\nformattedSolution += `If you need further assistance, simply reply to this message.\\n`;\n\nreturn {\n  json: {\n    ...data,\n    formatted_solution: formattedSolution,\n    feedback_url: `${$env.N8N_WEBHOOK_BASE_URL}/webhook/support/feedback/${data.case_id}`\n  }\n};"
      },
      "id": "format-direct-solution",
      "name": "Format Direct Solution",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2040, 400]
    },
    {
      "parameters": {
        "sendTo": "={{ $json.customer_context.email }}",
        "subject": "Support Case #{{ $json.case_id }}: Solution Ready",
        "message": "Dear {{ $json.customer_context.name }},\n\nThank you for contacting support. We've analyzed your issue and prepared a solution for you.\n\n---\n\n{{ $json.formatted_solution }}\n\n---\n\n**Case Details:**\n- Case ID: {{ $json.case_id }}\n- Category: {{ $json.classification.category }}\n- Priority: {{ $json.classification.priority }}\n\n**Did this help?**\n[Yes, issue resolved!]({{ $json.feedback_url }}?resolved=true)\n[No, I need more help]({{ $json.feedback_url }}?resolved=false)\n\nBest regards,\nSupport Team",
        "options": {}
      },
      "id": "send-solution-email",
      "name": "Send Solution Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2260, 400],
      "credentials": {
        "gmailOAuth2": {
          "id": "YOUR_GMAIL_CREDENTIAL_ID",
          "name": "Gmail"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO case_interactions (\n  case_id,\n  actor_type,\n  actor_id,\n  message,\n  interaction_type,\n  metadata\n) VALUES (\n  '{{ $json.case_id }}',\n  'system',\n  'self-service-agent',\n  '{{ $json.formatted_solution.replace(/'/g, \"''\") }}',\n  'solution',\n  '{{ JSON.stringify({ confidence: $json.solution.confidence, estimated_time: $json.solution.estimated_time }) }}'::jsonb\n);",
        "options": {}
      },
      "id": "log-solution-interaction",
      "name": "Log Solution",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [2480, 400],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  success: true,\n  case_id: $json.case_id,\n  status: 'solution_delivered',\n  message: 'Solution delivered to customer.',\n  solution_summary: {\n    estimated_time: $json.solution.estimated_time,\n    confidence: $json.solution.confidence,\n    steps_count: $json.solution.steps.length\n  }\n}, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" }
            ]
          }
        }
      },
      "id": "respond-solution-delivered",
      "name": "Respond - Solution Delivered",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [2700, 400]
    },
    {
      "parameters": {
        "path": "support/approve/:caseId",
        "httpMethod": "GET",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-approval",
      "name": "Webhook - Approval",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [240, 700],
      "webhookId": "support-approval-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Extract case ID from URL params\nconst caseId = $input.item.json.params?.caseId || $input.item.json.caseId;\n\nreturn {\n  json: {\n    case_id: caseId,\n    action: 'approved',\n    approved_at: new Date().toISOString()\n  }\n};"
      },
      "id": "parse-approval",
      "name": "Parse Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 700]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  c.*,\n  c.metadata->>'solution_pending' as has_pending_solution\nFROM cases c\nWHERE c.case_id = '{{ $json.case_id }}'\n  AND c.status = 'awaiting_approval';",
        "options": {}
      },
      "id": "fetch-pending-case",
      "name": "Fetch Pending Case",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [680, 700],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            {
              "id": "check-valid-case",
              "leftValue": "={{ $json.case_id }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-valid-approval",
      "name": "Valid Case?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [900, 700]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE cases \nSET status = 'executing_fix',\n    metadata = metadata || '{{ JSON.stringify({ approved_at: new Date().toISOString() }) }}'::jsonb\nWHERE case_id = '{{ $('Parse Approval').first().json.case_id }}';",
        "options": {}
      },
      "id": "update-approved",
      "name": "Mark Approved",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1120, 600],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// In a real implementation, this would call an API to execute the fix\n// For now, we simulate the fix execution\n\nconst caseData = $input.item.json;\n\n// Simulate fix execution\nconst executionResult = {\n  success: true,\n  executed_at: new Date().toISOString(),\n  output: 'Fix applied successfully. Please verify the issue is resolved.',\n  verification_steps: [\n    'Check system status',\n    'Verify configuration',\n    'Test the affected functionality'\n  ]\n};\n\nreturn {\n  json: {\n    case_id: $('Parse Approval').first().json.case_id,\n    execution_result: executionResult\n  }\n};"
      },
      "id": "execute-automated-fix",
      "name": "Execute Automated Fix",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE cases \nSET status = 'resolved',\n    resolution_type = 'self-service-automated',\n    resolved_at = NOW(),\n    resolution_time_minutes = EXTRACT(EPOCH FROM (NOW() - created_at))/60\nWHERE case_id = '{{ $json.case_id }}';",
        "options": {}
      },
      "id": "mark-resolved",
      "name": "Mark Resolved",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1560, 600],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "<!DOCTYPE html>\n<html>\n<head>\n  <title>Fix Applied Successfully</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }\n    .success { color: #059669; }\n    .card { background: #f9fafb; border-radius: 8px; padding: 20px; margin: 20px 0; }\n  </style>\n</head>\n<body>\n  <h1 class=\"success\">‚úÖ Fix Applied Successfully!</h1>\n  <div class=\"card\">\n    <h3>Case #{{ $json.case_id }}</h3>\n    <p>The automated fix has been applied to your system.</p>\n    <p><strong>What happened:</strong></p>\n    <p>{{ $json.execution_result.output }}</p>\n    <h4>Please verify:</h4>\n    <ul>\n      {{ $json.execution_result.verification_steps.map(step => '<li>' + step + '</li>').join('') }}\n    </ul>\n  </div>\n  <p>If you continue to experience issues, please reply to the support email.</p>\n</body>\n</html>",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "text/html" }
            ]
          }
        }
      },
      "id": "respond-approval-success",
      "name": "Approval Success Page",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1780, 600]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "<!DOCTYPE html>\n<html>\n<head>\n  <title>Invalid Request</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }\n    .error { color: #dc2626; }\n  </style>\n</head>\n<body>\n  <h1 class=\"error\">‚ùå Invalid or Expired Request</h1>\n  <p>This approval link is no longer valid. The case may have already been processed or the link has expired.</p>\n  <p>Please contact support if you need assistance.</p>\n</body>\n</html>",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "text/html" }
            ]
          }
        }
      },
      "id": "respond-invalid-approval",
      "name": "Invalid Approval Page",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1120, 800]
    },
    {
      "parameters": {
        "path": "support/feedback/:caseId",
        "httpMethod": "GET",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-feedback",
      "name": "Webhook - Feedback",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [240, 1000],
      "webhookId": "support-feedback-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Parse feedback from URL params\nconst caseId = $input.item.json.params?.caseId;\nconst resolved = $input.item.json.query?.resolved === 'true';\n\nreturn {\n  json: {\n    case_id: caseId,\n    resolved: resolved,\n    feedback_received_at: new Date().toISOString()\n  }\n};"
      },
      "id": "parse-feedback",
      "name": "Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 1000]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            {
              "id": "check-resolved",
              "leftValue": "={{ $json.resolved }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-resolved",
      "name": "Issue Resolved?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [680, 1000]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE cases \nSET status = 'resolved',\n    resolution_type = 'self-service-manual',\n    resolved_at = NOW(),\n    resolution_time_minutes = EXTRACT(EPOCH FROM (NOW() - created_at))/60\nWHERE case_id = '{{ $json.case_id }}';",
        "options": {}
      },
      "id": "mark-feedback-resolved",
      "name": "Mark Resolved (Feedback)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [900, 900],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "PostgreSQL - Support DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "<!DOCTYPE html>\n<html>\n<head>\n  <title>Thank You!</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }\n    .success { color: #059669; font-size: 48px; }\n  </style>\n</head>\n<body>\n  <div class=\"success\">üéâ</div>\n  <h1>Thank you for your feedback!</h1>\n  <p>We're glad we could help resolve your issue.</p>\n  <p>Your case #{{ $json.case_id }} has been marked as resolved.</p>\n</body>\n</html>",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "text/html" }
            ]
          }
        }
      },
      "id": "respond-feedback-resolved",
      "name": "Feedback - Resolved",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1120, 900]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_BASE_URL }}/webhook/support/collaborative",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ case_id: $json.case_id, escalation_reason: 'customer_feedback_unresolved' }) }}",
        "options": {}
      },
      "id": "escalate-to-collaborative",
      "name": "Escalate to Collaborative",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 1100]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "<!DOCTYPE html>\n<html>\n<head>\n  <title>We're Here to Help</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }\n    .info { color: #2563eb; font-size: 48px; }\n  </style>\n</head>\n<body>\n  <div class=\"info\">ü§ù</div>\n  <h1>We'll get you more help!</h1>\n  <p>Your case #{{ $json.case_id }} has been escalated to our support team.</p>\n  <p>A specialist will review your issue and reach out to you shortly.</p>\n</body>\n</html>",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "text/html" }
            ]
          }
        }
      },
      "id": "respond-feedback-escalated",
      "name": "Feedback - Escalated",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1120, 1100]
    },
    {
      "parameters": {
        "content": "## Workflow 2: Self-Service Resolution Engine\n\n**Purpose:** Automatically resolve common issues using knowledge base, AI reasoning, and optional automated remediation.\n\n### Flow:\n1. Receive case from Triage workflow\n2. Search knowledge sources:\n   - Error codes database\n   - Similar resolved cases\n   - Vector store (KB articles)\n3. AI generates solution\n4. Route based on approval needs:\n   - Requires approval ‚Üí Email with approve/decline\n   - No approval ‚Üí Direct solution delivery\n5. Handle customer feedback\n6. Escalate if needed\n\n### Webhook Endpoints:\n- `/support/self-service` - Main entry\n- `/support/approve/:caseId` - Approval handler\n- `/support/feedback/:caseId` - Feedback handler\n\n### Configuration Required:\n- PostgreSQL credentials\n- Supabase credentials\n- Anthropic (Claude) credentials\n- OpenAI credentials (embeddings)\n- Gmail credentials",
        "height": 520,
        "width": 360
      },
      "id": "sticky-note-info",
      "name": "Workflow Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [0, 80]
    }
  ],
  "connections": {
    "Webhook - Self-Service": {
      "main": [
        [{ "node": "Extract Case Data", "type": "main", "index": 0 }]
      ]
    },
    "Extract Case Data": {
      "main": [
        [
          { "node": "Lookup Error Codes", "type": "main", "index": 0 },
          { "node": "Find Similar Resolved Cases", "type": "main", "index": 0 },
          { "node": "KB Vector Search", "type": "main", "index": 0 }
        ]
      ]
    },
    "Lookup Error Codes": {
      "main": [
        [{ "node": "Merge Knowledge Sources", "type": "main", "index": 0 }]
      ]
    },
    "Find Similar Resolved Cases": {
      "main": [
        [{ "node": "Merge Knowledge Sources", "type": "main", "index": 0 }]
      ]
    },
    "KB Vector Search": {
      "main": [
        [{ "node": "Merge Knowledge Sources", "type": "main", "index": 0 }]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [{ "node": "KB Vector Search", "type": "ai_embedding", "index": 0 }]
      ]
    },
    "Merge Knowledge Sources": {
      "main": [
        [{ "node": "Solution Generator Agent", "type": "main", "index": 0 }]
      ]
    },
    "Solution Generator Agent": {
      "main": [
        [{ "node": "Combine Solution", "type": "main", "index": 0 }]
      ]
    },
    "Claude Sonnet - Solution": {
      "ai_languageModel": [
        [{ "node": "Solution Generator Agent", "type": "ai_languageModel", "index": 0 }]
      ]
    },
    "Solution Output Parser": {
      "ai_outputParser": [
        [{ "node": "Solution Generator Agent", "type": "ai_outputParser", "index": 0 }]
      ]
    },
    "Combine Solution": {
      "main": [
        [{ "node": "Requires Approval?", "type": "main", "index": 0 }]
      ]
    },
    "Requires Approval?": {
      "main": [
        [{ "node": "Update Awaiting Approval", "type": "main", "index": 0 }],
        [{ "node": "Update In Progress", "type": "main", "index": 0 }]
      ]
    },
    "Update Awaiting Approval": {
      "main": [
        [{ "node": "Format For Approval", "type": "main", "index": 0 }]
      ]
    },
    "Format For Approval": {
      "main": [
        [{ "node": "Send Approval Email", "type": "main", "index": 0 }]
      ]
    },
    "Send Approval Email": {
      "main": [
        [{ "node": "Respond - Approval Needed", "type": "main", "index": 0 }]
      ]
    },
    "Update In Progress": {
      "main": [
        [{ "node": "Format Direct Solution", "type": "main", "index": 0 }]
      ]
    },
    "Format Direct Solution": {
      "main": [
        [{ "node": "Send Solution Email", "type": "main", "index": 0 }]
      ]
    },
    "Send Solution Email": {
      "main": [
        [{ "node": "Log Solution", "type": "main", "index": 0 }]
      ]
    },
    "Log Solution": {
      "main": [
        [{ "node": "Respond - Solution Delivered", "type": "main", "index": 0 }]
      ]
    },
    "Webhook - Approval": {
      "main": [
        [{ "node": "Parse Approval", "type": "main", "index": 0 }]
      ]
    },
    "Parse Approval": {
      "main": [
        [{ "node": "Fetch Pending Case", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Pending Case": {
      "main": [
        [{ "node": "Valid Case?", "type": "main", "index": 0 }]
      ]
    },
    "Valid Case?": {
      "main": [
        [{ "node": "Mark Approved", "type": "main", "index": 0 }],
        [{ "node": "Invalid Approval Page", "type": "main", "index": 0 }]
      ]
    },
    "Mark Approved": {
      "main": [
        [{ "node": "Execute Automated Fix", "type": "main", "index": 0 }]
      ]
    },
    "Execute Automated Fix": {
      "main": [
        [{ "node": "Mark Resolved", "type": "main", "index": 0 }]
      ]
    },
    "Mark Resolved": {
      "main": [
        [{ "node": "Approval Success Page", "type": "main", "index": 0 }]
      ]
    },
    "Webhook - Feedback": {
      "main": [
        [{ "node": "Parse Feedback", "type": "main", "index": 0 }]
      ]
    },
    "Parse Feedback": {
      "main": [
        [{ "node": "Issue Resolved?", "type": "main", "index": 0 }]
      ]
    },
    "Issue Resolved?": {
      "main": [
        [{ "node": "Mark Resolved (Feedback)", "type": "main", "index": 0 }],
        [{ "node": "Escalate to Collaborative", "type": "main", "index": 0 }]
      ]
    },
    "Mark Resolved (Feedback)": {
      "main": [
        [{ "node": "Feedback - Resolved", "type": "main", "index": 0 }]
      ]
    },
    "Escalate to Collaborative": {
      "main": [
        [{ "node": "Feedback - Escalated", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [
    { "name": "support" },
    { "name": "self-service" },
    { "name": "resolution" }
  ],
  "meta": {
    "instanceId": "cx-catalyst"
  }
}
